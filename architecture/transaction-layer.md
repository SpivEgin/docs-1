---
title: Transaction Layer
summary: 
toc: false
---

CockroachDB aims to provide transactions with the same kind of simplicity you would experience if you developed against a local MySQL instance, despite allowing massively distributed deployments.

<div id="toc"></div>

## Overview

To provide consistency, CockroachDB implements full support for ACID semantic transactions in the Transaction Layer.

However, because CockroachDB is a fully distributed system, *all* statements are handled as transactions, including single statements. If you want to treat multiple statements as a single atomic unit, you can use the SQL standard `BEGIN`/`COMMIT`/`ROLLBACK` syntax.

Transactional consistency is accomplished through a two-phase commit process.

**Writing Intents (Phase 1)**

Instead of accessing values directly (like you would in a pessimistic concurrency control system that employs locks), CockroachDB instead handles access to MVCC values by writing two things:

- A **Transaction Record** stored on a coordinating node. This record includes the transaction’s current state (starting as `PENDING`), as well as a randomly assigned priority, which will be used to handle some cases of contention with other transaction. Though it’s random, the client can influence the priority by explicitly setting it to `LOW` or `HIGH` when initiating the transaction.

- **Intents* for all of a transaction’s interactions, which represent a provisional, uncommitted state. These are essentially the same as standard multi-version concurrency control (MVCC) values but also contain a special intent flag that points to the Transaction Record stored on the cluster. As long as the value exists as an intent, its values are treated as provisional. It’s important to conceptualize that CockroachDB also writes intents when reading data, which are used to prevent anomalies like stale reads.

** Checking for Contention (Phase 2)**
After a transaction writes all of its intents, it checks for conflicts with other transaction’s intents for the same keys. The primary decision for how these contentions is handled depends on the committing transaction’s isolation level. This setting is defined in the SQL statement, but is handled programmatically in the Transaction Layer.

- **Serializable Snapshot Isolation** (SSI) transactions, which is CockroachDB's default, cannot have their timestamp moved, and are much more likely to be restarted to prevent anomalies.

    When two `PENDING` SSI transactions are in contention, the transaction with the lower priority is put into the `PushTxnQueue`, as well as has its priority increased so it's make it more likely to succeed the next time it’s committed.

- **Snapshot Isolation** transactions can have their timestamps moved, which means that fewer transactions must be restarted (improving performance), but allows the write-skew anomaly into your database for each transaction that’s not restarted.

If a transaction is either uncontested or isn’t forced to restart, its transaction record is changed to COMMITTED and all of its intents will be converted them to standard MVCC values.

## Components

### Time & Hybrid Logical Clocks

In distributed systems, ordering and causality are difficult problems to solve. To make transactions more sensible, CockroachDB implements hybrid-logical clocks (HLC) which are composed of a physical component (thought of as and always close to local wall time) and a logical component (used to distinguish between events with the same physical component). This means that HLC time is always greater than or equal to the wall time. You can find more detail in the [HLC paper](http://www.cse.buffalo.edu/tech-reports/2014-04.pdf).

In terms of transactions, the gateway node picks a timestamp for the transaction using HLC time. Whenever a transaction's timestamp is mentioned, it's an HLC value. This timestamp is used to both track versions of values (through MVCC, which is detailed in the Storage Layer overview), as well as provide our transactional isolation guarantees.

When nodes send requests to other nodes, the sending node includes a timestamp generated by their local HLCs (which includes both physical and logical components). When nodes receive requests, they inform their local HLC of the timestamp supplied with the event by the sender. This is useful in guaranteeing that all data read/written on a node is at a timestamp < next HLC time.

#### Timestamp Cache

To provide linearlizability, whenever an operation reads a value, we store the operation's timestamp in a Timestamp Cache, which shows the high-water mark for values being read.

Whenever writes occur, their timestamps are checked against the TimestampCache to ensure its timestamp is greater than the Timestamp Cache (otherwise we would allow you to rewrite history, which produces anomalies). If the timestamp is less than, we attempt to bump it to a later timestamp than the cache.

#### Max Clock Offset Enforcement

To ensure correctness among distributed nodes, you can identify a Maximum Clock Offset. Because CockroachDB relies on clock synchronization, nodes run a version of [Marzullo’s algorithm](http://infolab.stanford.edu/pub/cstr/reports/csl/tr/83/247/CSL-TR-83-247.pdf) amongst themselves to measure maximum clock offset within the cluster. If the configured maximum offset is exceeded by any node, it commits suicide, preventing it from potentially creating consistency issues within the cluster.

### client.Txn and TxnCoordSender

As we mentioned in the SQL layer's architectural overview, CockroachDB converts all SQL statements into key-value (KV) operations, which is how data is ultimately stored and accessed. 

All of the KV operations generated from the SQL layer's parsing use `client.Txn`, which is the transactional interface for the CockroachDB KV layer––but, as we discussed above, all statements are transactions so everything ends up actually using this layer.

However, `client.Txn` is actually just a wrapper around `TxnCoordSender`, which is the first `client.Sender` for KV operations. TxnCoordSender plays a crucial role in our code base by:

- Dealing with transactions' state. After a transaction is started, the TxnCoordSender starts asynchronously sending heartbeat messages to that transaction's Transaction Records to keep it live. If the `TxnCoordSender`'s heartbeating stops, the Transaction Record is moved to `ABORTED` status.
- Tracking each written key or key range over the course of the transaction. 
- Clearing the accumulated write intents for the transaction when it's committed or aborted. All requests being performed as part of a transaction have to go through the same `TxnCoordSender` so that all write intents are accounted for and eventually cleaned up.

After setting up this bookkeeping, the request is passed to the `DistSender` in the Distribution Layer.

### Transaction Records

When a transaction starts, a Transaction Record's written to the node containing the first range modified in the transaction (this determination is done in the [Distribution Layer](distribution-layer.html)). This provides the system with a source of truth about the status of a transaction.

The Transaction Record can have a few potential values:

- `PENDING`: The initial status of all values, indicating that the transaction the write intent belongs to is in progress. Note that restarted transactions remain in this status because we continue to increment the transaction's priority in an attempt to cause transaction's likelihood of succeeding to increase the longer they remain in the system.
- `COMMITTED`: Once a transaction has completed, this status indicates that the value can be read. Whenever this status is encountered, the transaction status attribute is removed, converting the value from a Write Intent to a standard MVCC value.
- `ABORTED`: If a transaction fails entirely or is aborted by the client, it's moved into this state.

This record remains on the coordinating node until all of the intents it's responsible for are converted to MVCC values.

### Write Intents

Values in CockroachDB are not directly written to the storage layer; instead everything is written in a provisional state known as a "write intent." These are essentially multi-version concurrency control values (also known as MVCC, which is explained in greater depth in the Storage Layer) with an additional value added to them which identifies the transaction record to which the value belongs.

Whenever an operation encounters a Write Intent (instead of an MVCC value), it looks up the status of the the transaction record to understand how it should treat the Write Intent value.

How CockroachDB treats Write Intents depends on the status of the Transaction Record to which they point:

- `PENDING`: Because the transaction is still in progress, the new operation contends with the Write Intent and tries to push its timestamp forward. If the timestamp can't be pushed, this operation enters the `PushTxnQueue`.
- `COMMITTED`: The operation reads the Write Intent and converts it to an MVCC value by removing its pointer to the Transaction Record.
- `ABORTED`: The Write Intent is ignored and deleted.

### PushTxnQueue

Whenever an operation encounters a Write Intent, it checks its Transaction Record. If the Transaction Record is `PENDING`, the operations attempts to "push" the transaction it encounters, which means it increases its timestamp. If it succeeds in doing this or not depends on the transactions' priorities. Transactions with higher priorities can push those with lower priorities, but those with lower priorities cannot push those with higher priorities.

If the operation *cannot* push the transaction it encounters, it is placed in the `PushTxnQueue`, where it waits alongside any other transactions blocked by the same transaction.

The `PushTxnQueue`'s structure is a map of blocking transaction IDs to those they're blocking. For example:

~~~
txn1 -> txnA, txnB
txn2 -> txnD, txnC, txnF
~~~

Importantly, all of this activity is happening on a single node, where the transaction will resolve.

Once the transaction does resolve, a signal is sent to the `PushTxnQueue`, which lets all transactions that were blocked on it begin executing.

Waiting transactions also check the status of their own transaction to ensure they're still active. If the blocked transaction's been aborted, the operation simply removes itself.

## Interactions with Other Layers

Executing the query plan begins sending KV operations to the Transaction Layer.

In the Transaction Layer, the `TxnCoordSender` sends its KV requests to `DistSender` in the Distribution Layer.
